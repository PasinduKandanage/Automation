# -*- coding: utf-8 -*-
"""Alarm Classifier.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t7lmcsRrj4eKvrLqg_Uhl8gRcfpKuANO
"""

pip install pandas

from google.colab import drive
drive.mount('/content/drive')

!pip install tensorflow

# Step 1: Mount Google Drive
from google.colab import drive
import os

drive.mount("/content/drive", force_remount=True)

# Step 2: List Files in a Specific Directory
# Change 'your_directory' to the directory where your file is located
directory = '/content/drive/My Drive/Uploads'
files = os.listdir(directory)

# Step 3: Identify the File
# You can use a specific pattern or criteria to identify the file
# For example, if you are looking for a file with a specific extension
target_extension = '.zip'
target_files = [file for file in files if file.endswith(target_extension)]

# Print the identified files
print("Identified files:", target_files)

import pandas as pd
import zipfile
import re
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
from nltk.stem import WordNetLemmatizer
from sklearn.preprocessing import LabelEncoder
from keras.preprocessing.text import Tokenizer
from keras.preprocessing.sequence import pad_sequences
import nltk
import os
from google.colab import drive
from datetime import datetime

# Get the current date
current_date = datetime.now().strftime("%Y%m%d")

# Download NLTK data
nltk.download('stopwords')
nltk.download('punkt')
nltk.download('wordnet')

# Step 1: Mount Google Drive
drive.mount('/content/drive')

# Step 2: List Files in a Specific Directory
# Change 'your_directory' to the directory where your file is located
directory = '/content/drive/My Drive/Uploads'
files = os.listdir(directory)


# Step 3: Identify the File
target_extension = '.zip'
target_files = [file for file in files if file.endswith(target_extension)]

# Check if any target files are found
if not target_files:
    raise FileNotFoundError("No target files found with extension " + target_extension)

# Assuming you want to upload the first identified file
file_to_upload = os.path.join(directory, target_files[0])

# Step 4: Upload to '/content/current_date'
target_directory = '/content/'+ current_date

# Create the target directory if it doesn't exist
if not os.path.exists(target_directory):
    os.makedirs(target_directory)

# Copy the ZIP file to the target directory
!cp "{file_to_upload}" "{target_directory}"

print(f"File '{target_files[0]}' uploaded to '{target_directory}'")

# Step 3: Identify the File
# You can use a specific pattern or criteria to identify the file
# For example, if you are looking for a file with a specific extension
target_extension = '.zip'
target_files = [file for file in files if file.endswith(target_extension)]

# Print the identified files
print("Identified files:", target_files)

# Step 5: Rename the file
# Find the zip file in the current_date folder
zip_file_in_target = [f for f in os.listdir(target_directory) if f.endswith('.zip')][0]
old_file_path = os.path.join(target_directory, zip_file_in_target)

# Generate the new file name
new_file_name = f"CurrentAlarms_{current_date}.zip"
new_file_path = os.path.join(target_directory, new_file_name)

# Rename the file
os.rename(old_file_path, new_file_path)

print(f"File renamed to '{new_file_name}' in '{target_directory}'")

import shutil

# Define the source file path
source_file_path = '/content/' + current_date +'/CurrentAlarms_' + current_date + '.zip' # Added '/' after content

# Define the destination directory path
destination_dir_path = '/content/' + current_date

# Create the destination directory if it doesn't exist
os.makedirs(destination_dir_path, exist_ok=True)

# Construct the full destination file path
destination_file_path = os.path.join(destination_dir_path, os.path.basename(source_file_path))

# Move the file
shutil.move(source_file_path, destination_file_path)

print(f'File has been moved to: {destination_file_path}')

import os
import zipfile
from datetime import datetime

# Define the original zip file path
destination_dir_path = '/content/'+ current_date +'/CurrentAlarms_' + current_date + '.zip'

# Get the current date
current_date = datetime.now().strftime("%Y%m%d")

# Define the path to the extracted files directory
extracted_dir_path = '/content/'+ current_date + '/extracted_files'

# Create a directory for the extracted files
os.makedirs(extracted_dir_path, exist_ok=True)

# Extract the zip file
with zipfile.ZipFile(destination_dir_path, 'r') as zip_ref:
    zip_ref.extractall(extracted_dir_path)

# List the extracted files and rename them
extracted_files = os.listdir(extracted_dir_path)
for i, file_name in enumerate(extracted_files, start=1): # Use enumerate to get an index for each file starts from 1
    old_file_path = os.path.join(extracted_dir_path, file_name)
    name, ext = os.path.splitext(file_name) # Unpack the tuple into name and extension
    new_file_name = f"{name}_{current_date}_{i}{ext}" # Use f-string formatting to construct the new name
    destination_dir_path = os.path.join(extracted_dir_path, new_file_name)
    os.rename(old_file_path, destination_dir_path)

# List the renamed files
renamed_files = os.listdir(extracted_dir_path)
excel_files = [file for file in renamed_files if file.endswith('.xlsx') or file.endswith('.xls')]

# Count the number of Excel files
num_excel_files = len(excel_files)
print(f'Number of Excel files: {num_excel_files}')
print(f'Excel files: {excel_files}')

import pandas as pd
import os
from datetime import datetime

# Define the paths to the uploaded Excel files
excel_file_1_path = '/content/'+ current_date +'/extracted_files/CurrentAlarms20240718110241547_1_'+ current_date +'_1.xlsx'
excel_file_2_path = '/content/'+ current_date +'/extracted_files/CurrentAlarms20240718110241547_2_'+ current_date +'_2.xlsx'
excel_file_3_path = '/content/'+ current_date +'/extracted_files/CurrentAlarms20240718110241547_3_'+ current_date +'_3.xlsx'

# Extract the last digit from the filenames
last_digit_1 = excel_file_1_path[-6]
last_digit_2 = excel_file_2_path[-6]

# Print the extracted last digits
print(f'Last digit of the first Excel file: {last_digit_1}')
print(f'Last digit of the second Excel file: {last_digit_2}')

# Determine which file is the first based on the last digit
first_excel_file_path = excel_file_1_path if last_digit_1 == '1' else excel_file_2_path

# Load the first Excel file into a pandas DataFrame
df = pd.read_excel(first_excel_file_path)

# Load the Excel file, skipping the first 5 rows
excel_file_1_path = '/content/'+ current_date +'/extracted_files/CurrentAlarms20240718110241547_1_'+ current_date +'_1.xlsx'
df = pd.read_excel(excel_file_1_path, skiprows=5, engine='openpyxl')

# Display the dataframe to verify
print(df.head())

# Select the required columns
required_columns = ["Alarm ID", "Name", "Alarm Source", "Clearance Status", "Last Occurred (NT)"]
df = df[required_columns]

# Display the dataframe to verify
print(df.head())

import datetime
import pandas as pd

# Assuming df is already defined and contains the necessary columns

# Add the "Current Date" column as datetime
df["Current Date"] = pd.to_datetime(datetime.datetime.now().date())

# Convert "Last Occurred (NT)" to datetime
df["Last Occurred (NT)"] = pd.to_datetime(df["Last Occurred (NT)"], errors='coerce')

# Calculate the "Pending Days" column
df["Pending Days"] = (df["Current Date"] - df["Last Occurred (NT)"]).dt.days

# Display the dataframe to verify
print(df.head())

# Filter rows where "Pending Days" is greater than or equal 3
df = df[df["Pending Days"] >= 3]

# Assuming "Uncleared" is the status indicating not cleared. Adjust as necessary.
uncleared_status = "Uncleared"
df = df[df["Clearance Status"] == uncleared_status]

# Display the dataframe to verify
print(df.head())

# List of specific names to filter
names_to_filter = [
    "Configured Capacity Limit Exceeding Licensed Limit",
    "RF Unit Maintenance Link Failure",
    "RF Unit VSWR Threshold Crossed",
    "Cell Capability Degraded",
    "RF Unit TX Channel Gain Out of Range",
    "Board Hardware Fault",
    "Radio Link Failure",
    "RF Unit Hardware Fault",
    "System Dynamic Traffic Exceeding Licensed Limit"
]

# Filter rows by "Name"
df = df[df["Name"].isin(names_to_filter)]

# Display the dataframe to verify
print(df.head())

# Select the required columns
required_columns = ["Alarm ID", "Name", "Alarm Source", "Pending Days"]
df = df[required_columns]

# Display the dataframe to verify
print(df.head())

# Rename "Name" column to "Alarm Name"
df.rename(columns={'Name': 'Alarm Name'}, inplace=True)

# Keep only necessary columns
df = df[['Alarm ID', 'Alarm Name', 'Alarm Source', 'Pending Days']]

# Display the dataframe to verify
print(df.head())

# Save the filtered data to a new Excel file
filtered_excel_file_path = os.path.join(extracted_dir_path, 'File_No_1.xlsx')
df.to_excel(filtered_excel_file_path, index=False, engine='openpyxl')

for i, excel_file in enumerate(excel_files[1:], start=2):
    # Load each Excel file
    excel_2_file_path = os.path.join(extracted_dir_path, excel_file)
    df = pd.read_excel(excel_2_file_path)


# Determine which file is the second based on the last digit
second_excel_file_path = excel_file_2_path if last_digit_2 == '2' else excel_file_1_path

# Load the second Excel file into a pandas DataFrame
df = pd.read_excel(second_excel_file_path)

# Load the Excel file
excel_file_2_path = '/content/'+ current_date +'/extracted_files/CurrentAlarms20240718110241547_2_'+ current_date +'_2.xlsx'

# Display the dataframe to verify
print(df.head())

import os
import pandas as pd

# Define the paths to the uploaded Excel files
excel_files = [
    '/content/'+ current_date +'/extracted_files/CurrentAlarms20240718110241547_1_'+ current_date +'_1.xlsx',
    '/content/'+ current_date +'/extracted_files/CurrentAlarms20240718110241547_2_'+ current_date +'_2.xlsx',
    '/content/'+ current_date +'/extracted_files/CurrentAlarms20240718110241547_3_'+ current_date +'_3.xlsx',
    '/content/'+ current_date +'/extracted_files/CurrentAlarms20240718110241547_4_'+ current_date +'_4.xlsx',
    '/content/'+ current_date +'/extracted_files/CurrentAlarms20240718110241547_5_'+ current_date +'_5.xlsx'
]

# Extract the last digit from the filenames and create a dictionary
file_dict = {int(file[-6]): file for file in excel_files}

# Sort the dictionary by key (last digit)
sorted_files = [file_dict[key] for key in sorted(file_dict.keys())]

# Determine the second file in the sorted list
second_file_path = sorted_files[1]

print(f'The second Excel file based on the last digit is: {second_file_path}')

# Load and print the second Excel file
df_second = pd.read_excel(second_file_path)
print(df_second)

# Select the required columns
required_columns = ["Alarm ID", "Name", "Alarm Source", "Clearance Status", "Last Occurred (NT)"]
df = df[required_columns]

# Display the dataframe to verify
print(df.head())

import datetime
import pandas as pd

# Assuming df is already defined and contains the necessary columns

# Add the "Current Date" column as datetime
df["Current Date"] = pd.to_datetime(datetime.datetime.now().date())

# Convert "Last Occurred (NT)" to datetime
df["Last Occurred (NT)"] = pd.to_datetime(df["Last Occurred (NT)"], errors='coerce')

# Calculate the "Pending Days" column
df["Pending Days"] = (df["Current Date"] - df["Last Occurred (NT)"]).dt.days

# Display the dataframe to verify
print(df.head())

# Filter rows where "Pending Days" is greater than or equal 3
df = df[df["Pending Days"] >= 3]

# Assuming "Uncleared" is the status indicating not cleared. Adjust as necessary.
uncleared_status = "Uncleared"
df = df[df["Clearance Status"] == uncleared_status]

# Display the dataframe to verify
print(df.head())

# List of specific names to filter
names_to_filter = [
    "Configured Capacity Limit Exceeding Licensed Limit",
    "RF Unit Maintenance Link Failure",
    "RF Unit VSWR Threshold Crossed",
    "Cell Capability Degraded",
    "RF Unit TX Channel Gain Out of Range",
    "Board Hardware Fault",
    "Radio Link Failure",
    "RF Unit Hardware Fault",
    "System Dynamic Traffic Exceeding Licensed Limit"
]

# Filter rows by "Name"
df = df[df["Name"].isin(names_to_filter)]

# Display the dataframe to verify
print(df.head())

# Select the required columns
required_columns = ["Alarm ID", "Name", "Alarm Source", "Pending Days"]
df = df[required_columns]

# Display the dataframe to verify
print(df.head())

# Rename "Name" column to "Alarm Name"
df.rename(columns={'Name': 'Alarm Name'}, inplace=True)

# Keep only necessary columns
df = df[['Alarm ID', 'Alarm Name', 'Alarm Source', 'Pending Days']]

# Display the dataframe to verify
print(df.head())

# Save the filtered data to a new Excel file
filtered_excel_file_path = os.path.join(extracted_dir_path, 'File_No_2.xlsx')
df.to_excel(filtered_excel_file_path, index=False, engine='openpyxl')

# List of filtered Excel file paths
filtered_excel_files = [os.path.join(extracted_dir_path, f'File_No_{i}.xlsx') for i in range(1, num_excel_files + 1)]

# Combine all filtered data
combined_df = pd.concat([pd.read_excel(file) for file in filtered_excel_files])

# Merge and center similar values in "Alarm ID" and "Alarm Name" columns
combined_df['Alarm ID'] = combined_df['Alarm ID'].fillna(method='ffill')
combined_df['Alarm Name'] = combined_df['Alarm Name'].fillna(method='ffill')

# Save the final combined data to an Excel file
final_excel_file_path = os.path.join(extracted_dir_path, 'Filtered_Alarms_'+ current_date +'.xlsx')
combined_df.to_excel(final_excel_file_path, index=False, engine='openpyxl')

import pandas as pd
from openpyxl import load_workbook
from openpyxl.utils import get_column_letter
from openpyxl.styles import Alignment

# Define the path to the Excel file
excel_file_path = '/content/'+ current_date +'/extracted_files/Filtered_Alarms_'+ current_date +'.xlsx'

# Load the Excel file into a pandas DataFrame
df = pd.read_excel(excel_file_path)

# Specify the columns to merge
columns_to_merge = ["Alarm ID", "Alarm Name"]

# Save the DataFrame back to an Excel file to ensure it's in the latest format
temp_excel_path = '/content/'+ current_date +'/extracted_files/temp_merged.xlsx'
df.to_excel(temp_excel_path, index=False)

# Load the workbook
wb = load_workbook(temp_excel_path)
ws = wb.active

# Function to merge and center cells
def merge_and_center(ws, start_row, end_row, col_idx):
    col_letter = get_column_letter(col_idx)
    ws.merge_cells(f"{col_letter}{start_row}:{col_letter}{end_row}")
    cell = ws[f"{col_letter}{start_row}"]
    cell.alignment = Alignment(horizontal='center', vertical='center')

# Identify and merge duplicate values in specified columns
for col in columns_to_merge:
    col_idx = df.columns.get_loc(col) + 1
    start_row = None
    current_value = None

    for row in range(2, ws.max_row + 1):  # Start from row 2 assuming row 1 is the header
        cell_value = ws.cell(row=row, column=col_idx).value

        if cell_value != current_value:
            if start_row is not None:
                merge_and_center(ws, start_row, row - 1, col_idx)

            start_row = row
            current_value = cell_value

    # Merge the last set of duplicates
    if start_row is not None:
        merge_and_center(ws, start_row, ws.max_row, col_idx)

# Save the workbook with merged cells
output_path = '/content/'+ current_date +'/extracted_files/Final_Filtered_Alarms_'+ current_date +'.xlsx'
wb.save(output_path)

print(f'Merged and centered cells saved to: {output_path}')

import pandas as pd
import openpyxl

# Path to the filtered data (replace this with your actual file path)
input_file_path = '/content/'+ current_date +'/extracted_files/Final_Filtered_Alarms_'+ current_date +'.xlsx'

# Auto-fit the column width
def auto_fit_column_width(file_path):
    # Load the workbook and the active worksheet
    workbook = openpyxl.load_workbook(file_path)
    worksheet = workbook.active

    for column in worksheet.columns:
        max_length = 0
        column_letter = column[0].column_letter  # Get the column letter
        for cell in column:
            try:
                if len(str(cell.value)) > max_length:
                    max_length = len(str(cell.value))
            except:
                pass
        adjusted_width = (max_length + 2)
        worksheet.column_dimensions[column_letter].width = adjusted_width

    # Save the workbook with adjusted column widths
    workbook.save(file_path)

# Adjust column widths and save the file
auto_fit_column_width(input_file_path)

# Display the path to the saved file
print(f"Filtered data saved to {input_file_path}")

# Step 2: List Files in a Specific Directory
# Change 'your_directory' to the directory where your file is located
directory = '/content/drive/My Drive/Uploads'
files = os.listdir(directory)

# Step 3: Identify the Zip Files
target_extension = '.zip'
zip_files = [file for file in files if file.endswith(target_extension)]

# Print the identified zip files
print("Identified zip files:", zip_files)

# Step 4: Delete the Zip Files
for zip_file in zip_files:
    zip_file_path = os.path.join(directory, zip_file)
    os.remove(zip_file_path)
    print(f"Deleted zip file: {zip_file_path}")

print("Deletion of zip files completed.")

!pip install schedule
